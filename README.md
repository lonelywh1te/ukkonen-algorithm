# Алгоритм Укконена
_Берегалов А.С  
Дальневосточный федеральный университет  
Б9121.09.03.03пикд  
2022_
## Глоссарий
..
## Введение
Прежде чем говорить о Алгоритме Укконена, нужно знать что такое суффикскное дерево. 

> _Суффиксное дерево — бор, содержащий все суффиксы некоторой строки (и только их).  
Входные данные для алгоритма – это строка s, состоящая из n символов s[0], s[1], …, s[n-1]._

Оно выглядит следующим образом:  

![Дерево для строки "abcxa"](/images/img0.jpg)


Суффиксное дерево — дерево с n листьями, обладающее следующими свойствами:
 - каждая внутренняя вершина дерева имеет не меньше двух детей;
 - каждое ребро помечено непустой подстрокой строки s;
 - никакие два ребра, выходящие из одной вершины, не могут иметь пометок, начинающихся с одного и того же символа;
 - дерево должно содержать все суффиксы строки s, причем каждый суффикс заканчивается точно в листе и нигде кроме него.

Число вершин в таком дереве — O(n), поскольку листьев не более чем n + 1.

Теперь когда мы знакомы с базовым материалом, мы можем приступить собственно к самому алгоритму.
## Определение
> __Алгоритм Укконена__ (англ. Ukkonen's algorithm) — алгоритм построения суффиксного дерева для заданной строки s за линейное время.

Алгоритм построения суффиксного дерева за линейное время был придуман финским математиком Укконеном (Ukkonen) в 1995 году.  

Алгоритм Укконена строит суффиксное дерево, добавляя в него по одной букве. Текущая позиция в дереве соответствует максимальному неполному суффиксу уже добавленных букв, который уже встечался где-то раньше.

## Построение дерева за линейное время
### Строка без повторений
Чтобы понять как работает алгоритм, можно расписать его по шагам.   
Самый простой пример - строка без повторений.
> abc

Алгоритм работает по шагам, слева направо. Один шаг на каждый символ строки. 
Каждый шаг может включать в себя больше чем одну индивидуальную операцию.  

Мы начинаем слева и сначала вставляем одиночный символ **a** , создавая ребро из корня к листу и отмечаем его **[0, #]** - это означает что ребро представляет подстроку начинающуюся с позиции 0 и заканчивающуюся на текущем конце. Символ **#** означает индекс за символом (грубо говоря конец символа), то есть на данный момент # = 1;  

На данный момент наше дерево выглядит так: 

![Дерево для строки "a"](/images/img1_1.jpg)
![Дерево для строки "a"](/images/img1_0.jpg)  

Мы вставили символ **а**, теперь перейдем к следующему символу.  
**Цель: на каждом шаге вставлять все суффиксы до текущей позиции**  
Делается это с помощью расширения существующих ребер и добавлении нового ребра.  

Теперь дерево имеет вид:  

![Дерево для строки "a"](/images/img2_1.jpg)
![Дерево для строки "a"](/images/img2_0.jpg)

>Заметим, что **ab** такое же как и в начальном дереве **[0, #]**, так произошло из-за того что **#** теперь равен **2**.

Достроим дерево, добавив символ **с**:  

![Дерево для строки "a"](/images/img3_1.jpg)
![Дерево для строки "a"](/images/img3_0.jpg)

Так мы рассмотрели как строится дерево, которое не имеет повторяющихся символов. 

## Строка с повторениями
Пока в строке все символы уникальны, дерево строится очень просто.  
Теперь рассмотрим строку с повторениями:
>abcabxabz

Так как мы уже строили дерево для строки **abc**, то просто продолжим строить его.  
Добавим следующий символ **a** и дерево примет вид:  

![Дерево для строки "a"](/images/img4_0.jpg)

Теперь # = 4. Все наши ребра расширились, но добавлять новое ребро не стоит.  
Как можно заметить у нас есть ребро, которое начинается на символ **a**.  
В таких случаях мы вместо добавления нового ребра, спускаемся по уже существующему.  
Прежде чем сделать это, вводим еще четыре переменные (в дополнение к #), которые, конечно, существовали всё время, но до сих пор не использовались:
- активная вершина - вершина из которой выходит ребро
- активное ребро - индекс первого символа ребра по которому мы будем спускаться
- активная длина - количество символов, которое мы прошли по ребру (насколько мы спустились по ребру)
- остаток - количество суффиксов которые осталось добавить.
 
> Как только мы спустились по ребру, наши переменные имеют значения:
> - активная вершина = корень
> - активное ребро = 3 (потому что первый символ в ребре равен символу который мы пытались добавить, а его индекс в свою очередь равен трём.)
> - активная длина = 1 (спустились по ребру на один символ, можно заметить на фото: наша позиция отмечена чертой)
> - остаток = 1


## Теория
### Правила продления суффиксов
Пусть _S[j..i]_ = β — суффикс _S[1..i]_. В продолжении j, когда алгоритм находит конец β в текущем дереве, он продолжает β, чтобы обеспечить присутствие суффикса _βS(i + 1)_ в дереве. Алгоритм действует по одному из следующих трех правил.

__Правило 1.__ В текущем дереве путь β кончается в листе. Это значит, что путь от корня с меткой β доходит до конца некоторой «листовой» дуги (дуги, входящей в лист). При изменении дерева нужно добавить к концу метки этой листовой дуги символ _S(i + 1)_.  

__Правило 2.__ Ни один путь из конца строки β не начинается символом _S(i + 1)_, но по крайней мере один начинающийся оттуда путь имеется. В этом случае должна быть создана новая листовая дуга, начинающаяся в конце β, помеченная символом _S(i + 1)_. При этом, если β кончается внутри дуги, должна быть создана новая вершина. Листу в конце новой листовой дуги сопоставляется номер j. Таким образом, в правиле 2 возможно два случая.  

__Правило 3.__ Некоторый путь из конца строки β начинается символом _S(i + 1)_. В этом случае строка _βS(i + 1)_ уже имеется в текущем дереве, так что ничего не надо делать (в неявном суффиксном дереве конец суффикса не нужно помечать явно).
### Наивный метод O(n³)
Алгоритм последовательно строит неявные суффиксные деревья_ для всех префиксов исходного текста _S = s₁s₂…sₙ_. 
На i-ой фазе неявное суффиксное дерево tᵢ-₁ для префикса _s[1…i − 1]_ достраивается до tᵢ для префикса _s[1…i]_. 
Достраивание происходит следующим образом: для каждого суффикса подстроки _s[1…i − 1]_ необходимо спуститься от корня дерева до конца этого суффикса и дописать символ sᵢ.  

Алгоритм состоит из n фаз. На каждой фазе происходит продление всех суффиксов текущего префикса строки, что требует O(n²) времени. Следовательно, общая асимптотика алгоритма составляет O(n³).

>__Неявное суффиксное дерево__ (англ. implicit suffix tree, IST) — это суффиксное дерево, построенное для строки S без добавления $.
### Суффиксные ссылки
> Пусть xA обозначает произвольную строку, где x — её первый символ, а A — оставшаяся подстрока (возможно пустая). Если для внутренней вершины _v_ с ребром xА существует другая вершина _s(v)_ с ребром α, то ссылка из _v_ в _s(v)_ называется __суффиксной ссылкой__ (англ. suffix link).
#### Построение суффиксных ссылок
Рассмотрим новую внутреннюю вершину _v_, которая была создана в результате продления суффикса _s[j…i − 1]_. 
Вместо того, чтобы искать, куда должна указывать суффиксная ссылка вершины _v_, поднимаясь от корня дерева для этого, перейдем к продлению следующего суффикса _s[j+1…i−1]_. И в этот момент можно проставить суффиксную ссылку для вершины _v_. 
Она будет указывать либо на существующую вершину, если следующий суффикс закончился в ней, либо на новую созданную. То есть суффиксные ссылки будут обновляться с запаздыванием.
#### Использование суффиксных ссылок
Пусть только что был продлён суффикс _[j…i − 1]_ до суффикса _s[j…i]_.  
Теперь с помощью построенных ссылок можно найти конец суффикса _s[j + 1…i − 1]_ в суффиксном дереве, чтобы продлить его до суффикса _s[j + 1…i]_. Для этого надо пройти вверх по дереву до ближайшей внутренней вершины _v_, в которую ведёт путь, помеченный _s[j…r]_. У вершины _v_ точно есть суффиксная ссылка. Эта суффиксная ссылка ведёт в вершину _u_, которой соответствует путь, помеченный подстрокой _s[j + 1…r]_. Теперь от вершины u следует пройти вниз по дереву к концу суффикса _s[j + 1…i − 1]_ и продлить его до суффикса _s[j + 1…i]_.

Подстрока _s[j + 1…i − 1]_ является суффиксом подстроки _s[j…i − 1]_, следовательно после перехода по суффиксной ссылке в вершину, помеченную путевой меткой _s[j + 1…r]_, можно дойти до места, которому соответствует метка _s[r + 1…i − 1]_, сравнивая не символы на рёбрах, а лишь длину ребра по первому символу рассматриваемой части подстроки и длину самой этой подстроки. Таким образом можно спускаться вниз сразу на целое ребро.
#### Лемма: При переходе по суффиксной ссылке глубина уменьшается не более чем на 1.
>_Глубиной вершины назовем число рёбер на пути от корня до вершины _v__.

__Доказательство__:
Заметим, что на пути A в дереве по суффиксу _s[j + 1…i]_ не более чем на одну вершину меньше, чем на пути B по суффиксу _s[j…i]_. Каждой вершине _v_ на пути B соответствует вершина _u_ на пути A, в которую ведёт суффиксная ссылка. Разница в одну вершину возникает, если первому ребру в пути B соответсвует метка из одного символа _sⱼ_, тогда суффиксная ссылка из вершины, в которую ведёт это ребро, будет вести в корень.
#### Лемма _(о числе переходов внутри фазы)_: Число переходов по рёбрам внутри фазы номер i равно O(i).
__Доказательство__:
Оценим количество переходов по рёбрам при поиске конца суффикса. Переход до ближайшей внутренней вершины уменьшает высоту на 1. Переход по суффиксной ссылке уменьшает высоту не более чем на 1 (по лемме, доказанной выше). А потом высота увеличивается, пока мы переходим по рёбрам вниз. Так как высота не может увеличиваться больше глубины дерева, а на каждой j-ой итерации мы уменьшаем высоту не более, чем на 2, то суммарно высота не может увеличиться больше чем на 2i. Итого, число переходов по рёбрам за одну фазу в сумме составляет O(i).

#### Асимптотика алгоритма с использованием суффиксных ссылок
Теперь в начале каждой фазы мы только один раз спускаемся от корня, а дальше используем переходы по суффиксным ссылкам.   
По доказанной лемме переходов внутри фазы будет O(i). А так как фаза состоит из i итераций, то амортизационно получаем, что на одной итерации будет выполнено O(1) действий.  
Следовательно, асимптотика алгоритма улучшилась до O(n²).

### Алгоритм O(n)
Чтобы улучшить время работы данного алгоритма до O(n), нужно использовать линейное количество памяти, поэтому метка каждого ребра будет храниться как два числа — позиции её самого левого и самого правого символов в исходном тексте.
#### Итоговая оценка времени работы
В течение работы алгоритма создается не более O(n) вершин по лемме о размере суффиксного дерева для строки. Все суффиксы, которые заканчиваются в листах, благодаря первой лемме на каждой итерации мы увеличиваем на текущий символ по умолчанию за O(1). Текущая фаза алгоритма будет продолжаться, пока не будет использовано правило продления 3.  
Сначала неявно продлятся все листовые суффиксы, а потом по правилу 2 будет создано несколько новых внутренних вершин. Так как вершин не может быть создано больше, чем их есть, то амортизационно на каждой фазе будет создано O(1) вершин. Так как мы на каждой фазе начинаем добавление суффикса не с корня, а с индекса j∗, на котором в прошлой фазе было применено правило 3, то используя немного модифицированный вариант леммы о числе переходов внутри фазы нетрудно показать, что суммарное число переходов по рёбрам за все n фаз равно O(n).

Таким образом, при использовании всех приведённых эвристик алгоритм Укконена работает за O(n).
## Реализация
### Cтруктура дерева
> #### Вершина (node)
> - `int left, *right` - индекс первого / последнего символа суффикса
> - `node *suff_link` - суффиксная ссылка
> - `map<char, *node> childs` - массив детей
> - `конструктор node`

> `string str` - строка, по которой строится дерево  
> `node *active_node` - вершина с которой начнется расширение  
> `int active_edge`  - активное ребро, иначе говоря индекс символа ребра по которому будем спускаться  
> `int active_length`  - длина которую прошли по ребру  
> `int remainder`  - остаток суффиксов  
> `int suff_end` - хранит последний индекс для листьев  
> `node *root` - корень дерева  
> `node *last_created` - последняя созданная вершина 

### Конструктор Node
```c++
node(int left, int *right, node *suffix_link, int suff_index) {
this->left = left;
this->right = right;
this->suff_link = suffix_link;
this->suff_index = suff_index;
}
```
### Функция подсчета длины ребра
```c++
int suffix_length(node *node) {
    return *node->right - node->left + 1;
}
```
### Функция построения дерева
```c++
void build(string data) {
    str = data + "$";
    active_node = root;

    for(int i = 0; i < str.length(); i++){
        update_tree(i);
    }
}
```
### Функция расширения дерева
```c++
void update_tree(int index){
    last_created = nullptr;
    remainder++;
    suff_end++;
    
    while (remainder != 0){
        // задаем активное ребро
        if (active_length == 0) {
            active_edge = index;
        }
        // ищем ребенка(суффикс) который начинается на заданный символ
        auto finded_child = active_node->childs.find(str[active_edge]);
        node *finded_node = finded_child->second;
        
        // если нет такого суффикса который начинается на данный символ
        if (finded_child == active_node->childs.end()){
            node *added_letter = new node(index, &suff_end, root, index - remainder + 1);
            active_node->childs.insert(make_pair(str[index], added_letter));
            if (last_created != nullptr) {
                last_created->suff_link = active_node;
                last_created = nullptr;
            }
        }
        else {
            // если можем спуститься к ноде - спускаемся
            if (active_length == suffix_length(finded_node)){
                   active_node = finded_node;
                   active_length = 0;
                   active_edge = -1;
                   continue;
            }
            //если можем спуститься по ребру - спускаемся
            if (str[index] == str[finded_child->second->left + active_length]){
                if (last_created != nullptr && active_node != root) last_created->suff_link = active_node;
                active_length++;
                break;
            }
            // деление ребра
            node *new_node = new node(finded_node->left, new int(finded_node->left + active_length - 1), root, -1);
            // создаем суффиксную ссылку
            if (last_created != nullptr) last_created->suff_link = new_node;
            active_node->childs[str[active_edge]] = new_node;
            finded_node->left += active_length;
            new_node->childs.insert(make_pair(str[index], new node(index, &suff_end, root, index - remainder + 1)));
            new_node->childs.insert(make_pair(str[finded_node->left], finded_node));
            last_created = new_node;
        }
        remainder--;
        
        if (active_length > 0 && active_node == root){
            active_length--;
            active_edge++;
        }
        else if (active_node != root){
            active_node = active_node->suff_link;
        }
    }
}
```
### Вывод дерева
```c++
void print(node *start, int lvl) {
    // перебор нод
    for(auto i : start->childs){
        for(int k = 0; k < lvl; k++){
            cout << "-----";
        }
        // вывод суффикса
        for(int j = i.second->left; j <= *(i.second->right); j++){
            cout << str[j];
        }
        cout << endl;
        // спуск по детям
        if(!(start->childs.empty())){
            print(i.second, lvl+1);
        }
    }
}
```
## Источники  
- [Простое суффиксное дерево / Хабр](https://habr.com/ru/post/258121/)
- [Алгоритм Укконена — Викиконспекты](https://vk.cc/cj1OgK)
- [АиСД S03E12. Суффиксное дерево. Алгоритм Укконена](https://www.youtube.com/watch?v=WjzR1eFbAeo&t=1328s&ab_channel=PavelMavrin)
- [Visualization of Ukkonen's Algorithm](http://brenden.github.io/ukkonen-animation/)
- [Ukkonen's suffix tree algorithm in plain English / stackoverflow](https://stackoverflow.com/questions/9452701/ukkonens-suffix-tree-algorithm-in-plain-english/9513423#9513423)
- [Suffix tree. Ukkonen's algorithm - Codeforces](https://codeforces.com/blog/entry/16780?f0a28=1)

