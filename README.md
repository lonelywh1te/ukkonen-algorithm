# Алгоритм Укконена
_Берегалов А.С  
Дальневосточный федеральный университет  
Б9121.09.03.03пикд  
2022_

## Введение
Прежде чем говорить о Алгоритме Укконена, нужно знать что такое суффикскное дерево. 

> _Суффиксное дерево — бор, содержащий все суффиксы некоторой строки (и только их).  
Входные данные для алгоритма – это строка s, состоящая из n символов s[0], s[1], …, s[n-1]._

Оно выглядит следующим образом:  

![Дерево для строки "abcxa"](/images/img0.jpg)


Суффиксное дерево — дерево с n листьями, обладающее следующими свойствами:
 - каждая внутренняя вершина дерева имеет не меньше двух детей;
 - каждое ребро помечено непустой подстрокой строки s;
 - никакие два ребра, выходящие из одной вершины, не могут иметь пометок, начинающихся с одного и того же символа;
 - дерево должно содержать все суффиксы строки s, причем каждый суффикс заканчивается точно в листе и нигде кроме него.

Число вершин в таком дереве — O(n), поскольку листьев не более чем n + 1.

Теперь когда мы знакомы с базовым материалом, мы можем приступить собственно к самому алгоритму.
## Определение
> __Алгоритм Укконена__ (англ. Ukkonen's algorithm) — алгоритм построения суффиксного дерева для заданной строки s за линейное время.

Алгоритм построения суффиксного дерева за линейное время был придуман финским математиком Укконеном (Ukkonen) в 1995 году.  

Алгоритм Укконена строит суффиксное дерево, добавляя в него по одной букве. Текущая позиция в дереве соответствует максимальному неполному суффиксу уже добавленных букв, который уже встечался где-то раньше.

## Построение дерева за линейное время
В процессе
## Теория
### Правила продления суффиксов
Пусть _S[j..i]_ = β — суффикс _S[1..i]_. В продолжении j, когда алгоритм находит конец β в текущем дереве, он продолжает β, чтобы обеспечить присутствие суффикса _βS(i + 1)_ в дереве. Алгоритм действует по одному из следующих трех правил.

__Правило 1.__ В текущем дереве путь β кончается в листе. Это значит, что путь от корня с меткой β доходит до конца некоторой «листовой» дуги (дуги, входящей в лист). При изменении дерева нужно добавить к концу метки этой листовой дуги символ _S(i + 1)_.  

__Правило 2.__ Ни один путь из конца строки β не начинается символом _S(i + 1)_, но по крайней мере один начинающийся оттуда путь имеется. В этом случае должна быть создана новая листовая дуга, начинающаяся в конце β, помеченная символом _S(i + 1)_. При этом, если β кончается внутри дуги, должна быть создана новая вершина. Листу в конце новой листовой дуги сопоставляется номер j. Таким образом, в правиле 2 возможно два случая.  

__Правило 3.__ Некоторый путь из конца строки β начинается символом _S(i + 1)_. В этом случае строка _βS(i + 1)_ уже имеется в текущем дереве, так что ничего не надо делать (в неявном суффиксном дереве конец суффикса не нужно помечать явно).
### Наивный метод O(n³)
Алгоритм последовательно строит неявные суффиксные деревья_ для всех префиксов исходного текста _S = s₁s₂…sₙ_. 
На i-ой фазе неявное суффиксное дерево tᵢ-₁ для префикса _s[1…i − 1]_ достраивается до tᵢ для префикса _s[1…i]_. 
Достраивание происходит следующим образом: для каждого суффикса подстроки _s[1…i − 1]_ необходимо спуститься от корня дерева до конца этого суффикса и дописать символ sᵢ.  

Алгоритм состоит из n фаз. На каждой фазе происходит продление всех суффиксов текущего префикса строки, что требует O(n²) времени. Следовательно, общая асимптотика алгоритма составляет O(n³).

>__Неявное суффиксное дерево__ (англ. implicit suffix tree, IST) — это суффиксное дерево, построенное для строки S без добавления $.
### Суффиксные ссылки
> Пусть xA обозначает произвольную строку, где x — её первый символ, а A — оставшаяся подстрока (возможно пустая). Если для внутренней вершины _v_ с ребром xА существует другая вершина _s(v)_ с ребром α, то ссылка из _v_ в _s(v)_ называется __суффиксной ссылкой__ (англ. suffix link).
#### Построение суффиксных ссылок
Рассмотрим новую внутреннюю вершину _v_, которая была создана в результате продления суффикса _s[j…i − 1]_. 
Вместо того, чтобы искать, куда должна указывать суффиксная ссылка вершины _v_, поднимаясь от корня дерева для этого, перейдем к продлению следующего суффикса _s[j+1…i−1]_. И в этот момент можно проставить суффиксную ссылку для вершины _v_. 
Она будет указывать либо на существующую вершину, если следующий суффикс закончился в ней, либо на новую созданную. То есть суффиксные ссылки будут обновляться с запаздыванием.
#### Использование суффиксных ссылок
Пусть только что был продлён суффикс _[j…i − 1]_ до суффикса _s[j…i]_.  
Теперь с помощью построенных ссылок можно найти конец суффикса _s[j + 1…i − 1]_ в суффиксном дереве, чтобы продлить его до суффикса _s[j + 1…i]_. Для этого надо пройти вверх по дереву до ближайшей внутренней вершины _v_, в которую ведёт путь, помеченный _s[j…r]_. У вершины _v_ точно есть суффиксная ссылка. Эта суффиксная ссылка ведёт в вершину _u_, которой соответствует путь, помеченный подстрокой _s[j + 1…r]_. Теперь от вершины u следует пройти вниз по дереву к концу суффикса _s[j + 1…i − 1]_ и продлить его до суффикса _s[j + 1…i]_.

Подстрока _s[j + 1…i − 1]_ является суффиксом подстроки _s[j…i − 1]_, следовательно после перехода по суффиксной ссылке в вершину, помеченную путевой меткой _s[j + 1…r]_, можно дойти до места, которому соответствует метка _s[r + 1…i − 1]_, сравнивая не символы на рёбрах, а лишь длину ребра по первому символу рассматриваемой части подстроки и длину самой этой подстроки. Таким образом можно спускаться вниз сразу на целое ребро.
#### Лемма: При переходе по суффиксной ссылке глубина уменьшается не более чем на 1.
>_Глубиной вершины назовем число рёбер на пути от корня до вершины _v__.

__Доказательство__:
Заметим, что на пути A в дереве по суффиксу _s[j + 1…i]_ не более чем на одну вершину меньше, чем на пути B по суффиксу _s[j…i]_. Каждой вершине _v_ на пути B соответствует вершина _u_ на пути A, в которую ведёт суффиксная ссылка. Разница в одну вершину возникает, если первому ребру в пути B соответсвует метка из одного символа _sⱼ_, тогда суффиксная ссылка из вершины, в которую ведёт это ребро, будет вести в корень.
#### Лемма _(о числе переходов внутри фазы)_: Число переходов по рёбрам внутри фазы номер i равно O(i).
__Доказательство__:
Оценим количество переходов по рёбрам при поиске конца суффикса. Переход до ближайшей внутренней вершины уменьшает высоту на 1. Переход по суффиксной ссылке уменьшает высоту не более чем на 1 (по лемме, доказанной выше). А потом высота увеличивается, пока мы переходим по рёбрам вниз. Так как высота не может увеличиваться больше глубины дерева, а на каждой j-ой итерации мы уменьшаем высоту не более, чем на 2, то суммарно высота не может увеличиться больше чем на 2i. Итого, число переходов по рёбрам за одну фазу в сумме составляет O(i).

#### Асимптотика алгоритма с использованием суффиксных ссылок
Теперь в начале каждой фазы мы только один раз спускаемся от корня, а дальше используем переходы по суффиксным ссылкам.   
По доказанной лемме переходов внутри фазы будет O(i). А так как фаза состоит из i итераций, то амортизационно получаем, что на одной итерации будет выполнено O(1) действий.  
Следовательно, асимптотика алгоритма улучшилась до O(n²).

### Алгоритм O(n)
Чтобы улучшить время работы данного алгоритма до O(n), нужно использовать линейное количество памяти, поэтому метка каждого ребра будет храниться как два числа — позиции её самого левого и самого правого символов в исходном тексте.
#### Итоговая оценка времени работы
В течение работы алгоритма создается не более O(n) вершин по лемме о размере суффиксного дерева для строки. Все суффиксы, которые заканчиваются в листах, благодаря первой лемме на каждой итерации мы увеличиваем на текущий символ по умолчанию за O(1). Текущая фаза алгоритма будет продолжаться, пока не будет использовано правило продления 3.  
Сначала неявно продлятся все листовые суффиксы, а потом по правилу 2 будет создано несколько новых внутренних вершин. Так как вершин не может быть создано больше, чем их есть, то амортизационно на каждой фазе будет создано O(1) вершин. Так как мы на каждой фазе начинаем добавление суффикса не с корня, а с индекса j∗, на котором в прошлой фазе было применено правило 3, то используя немного модифицированный вариант леммы о числе переходов внутри фазы нетрудно показать, что суммарное число переходов по рёбрам за все n фаз равно O(n).

Таким образом, при использовании всех приведённых эвристик алгоритм Укконена работает за O(n).
## Реализация
В процессе
## Источники  
- [Простое суффиксное дерево / Хабр](https://habr.com/ru/post/258121/)
- [Алгоритм Укконена — Викиконспекты](https://vk.cc/cj1OgK)
- [Visualization of Ukkonen's Algorithm](http://brenden.github.io/ukkonen-animation/)
- [Ukkonen's suffix tree algorithm in plain English / stackoverflow](https://stackoverflow.com/questions/9452701/ukkonens-suffix-tree-algorithm-in-plain-english/9513423#9513423)
- [Suffix tree. Ukkonen's algorithm - Codeforces](https://codeforces.com/blog/entry/16780?f0a28=1)
