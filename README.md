# Алгоритм Укконена
_Берегалов А.С  
Дальневосточный федеральный университет  
Б9121.09.03.03пикд  
2022_

## Содержание
- [Содержание]
- [Глоссарий]
- [Введение]
- [Определение]
- [Построение дерева за линейное время]
    - [Строка без повторений]
    - [Строка с повторениями]
- [Теория]
    - [Правила продления суффиксов]
    - [Наивный метод]
    - [Суффиксные ссылки]
        - [Построение суффиксных ссылок]
        - [Использование суффиксных ссылок]
        - [Лемма-1]
        - [Лемма-2]
        - [Асимптотика алгоритма с использованием суффиксных ссылок]
    - [Алгоритм O(n)]
        - [Итоговая оценка времени работы]
- [Реализация]
    - [Структура дерева]
    - [Конструктор Node]
    - [Функция подсчета длины ребра]
    - [Функция построения дерева]
    - [Функция расширения дерева]
    - [Вывод дерева]
    - [Источники]
## Глоссарий
- Бор (англ. trie, луч, нагруженное дерево) — структура данных для хранения набора строк, представляющая из себя подвешенное дерево с символами на рёбрах.
- Внутренняя вершина — любая вершина дерева, имеющая потомков, и таким образом, не являющаяся листом.
- Корень — самый верхний узел дерева.
- Лист — узел, не имеющий дочерних элементов (детей).
- Неявное суффиксное дерево (англ. implicit suffix tree, IST) строки S — это суффиксное дерево, построенное для строки S без добавления $.
- Подстрока — это часть строки, состоящая из некоторого количества смежных символов исходной строки.
- Суффикс — это подстрока строки S, начинающеяся в позиции i и зканчивающеяся в m - где m это длина строки S.
## Введение
Алгоритм Укконена основывается на понятии суффиксного дерева

> _Суффиксное дерево — бор, содержащий все суффиксы некоторой строки (и только их).  
Входные данные для алгоритма – это строка s, состоящая из n символов s[0], s[1], …, s[n-1]._

Оно выглядит следующим образом:  

![Дерево для строки "abcxa"](/images/img0.jpg)  
_Дерево для строки "abcxa"_

Суффиксное дерево — дерево с n листьями, обладающее следующими свойствами:
 - каждая внутренняя вершина дерева имеет не меньше двух детей;
 - каждое ребро помечено непустой подстрокой строки s;
 - никакие два ребра, выходящие из одной вершины, не могут иметь пометок, начинающихся с одного и того же символа;
 - дерево должно содержать все суффиксы строки s, причем каждый суффикс заканчивается точно в листе и нигде кроме него.

Число вершин в таком дереве — O(n), поскольку листьев не более чем n + 1.

Теперь когда мы знакомы с базовым материалом, мы можем приступить собственно к самому алгоритму.
## Определение
> __Алгоритм Укконена__ (англ. Ukkonen's algorithm) — алгоритм построения суффиксного дерева для заданной строки s за линейное время.

Алгоритм построения суффиксного дерева за линейное время был придуман финским математиком Укконеном (Ukkonen) в 1995 году.  

Алгоритм Укконена строит суффиксное дерево, добавляя в него по одной букве. Текущая позиция в дереве соответствует максимальному неполному суффиксу уже добавленных букв, который уже встечался где-то раньше.

## Построение дерева за линейное время
### Строка без повторений
Самый простой пример для построения дерева - строка без повторений.
> abc

Алгоритм работает пошагово, проходя по строке слева направо. Один шаг на каждый символ строки. 
Каждый шаг может включать в себя больше чем одну операцию.  

Построение начинается слева и сначала вставляется одиночный символ **a** , создавая ребро из корня к листу и хранится как  **[0, #]** - это означает что ребро представляет собой подстроку начинающуюся с позиции 0 и заканчивающуюся на текущем конце. Символ **#** означает индекс за символом (грубо говоря конец символа), то есть на данный момент # = 1;  

На данный момент дерево выглядит так: 

![Дерево для строки "a"](/images/img1_1.jpg)
![Дерево для строки "a"](/images/img1_0.jpg)  
_Рис.1,2 Дерево для строки "a"_  

Был вставлен символ **а**, теперь перейдем к следующему символу.  
**Цель: на каждом шаге вставлять все суффиксы до текущей позиции**  
Делается это с помощью расширения существующих ребер и добавлении нового ребра.  

Теперь дерево имеет вид:  

![Дерево для строки "ab"](/images/img2_1.jpg)
![Дерево для строки "ab"](/images/img2_0.jpg)  
_Рис.3,4 Дерево для строки "ab"_


>Заметим, что ребро **ab** такое же как и ребро **a** из рисунков выше и хранится как **[0, #]**, так произошло из-за того что **#** теперь равен **2**.

Достроим дерево, добавив символ **с**:  

![Дерево для строки "abc"](/images/img3_1.jpg)
![Дерево для строки "abc"](/images/img3_0.jpg)  
_Рис.5,6 Дерево для строки "abc"_

Так мы рассмотрели как строится дерево, которое не имеет повторяющихся символов.

## Строка с повторениями
Пока в строке все символы уникальны, дерево строится очень просто.  
Теперь рассмотрим строку с повторениями:
>abcabxabz

Так как мы уже строили дерево для строки **abc**, то просто продолжим строить его.  
Добавим следующий символ **a** и дерево примет вид:  

![Дерево для строки "abca"](/images/img4_0.jpg)  
_Рис.7 Дерево для строки "abca"_


Теперь # = 4. Все наши ребра расширились, но добавлять новое ребро не стоит.  
Как можно заметить у нас есть ребро, которое начинается на символ **a**.  
В таких случаях мы вместо добавления нового ребра, спускаемся по уже существующему.  
Прежде чем сделать это, вводим еще четыре переменные (в дополнение к #), которые, конечно, существовали всё время, но до сих пор не использовались:
- активная вершина - вершина из которой выходит ребро
- активное ребро - индекс первого символа ребра по которому мы будем спускаться
- активная длина - количество символов, которое мы прошли по ребру (насколько мы спустились по ребру)
- остаток - количество суффиксов которые осталось добавить.
 
> Как только мы спустились по ребру, наши переменные имеют значения:
> - активная вершина = корень
> - активное ребро = 3 (потому что первый символ в ребре равен символу который мы пытались добавить, а его индекс в свою очередь равен трём.)
> - активная длина = 1 (спустились по ребру на один символ, можно заметить на фото: наша позиция отмечена чертой)
> - остаток = 1

Следующий шаг: добавляем символ **b**.   
Переменная # = 5, заметим, что мы находились внутри ребра, символ который мы добавляем уже есть в этом ребре, поэтому мы просто спускаемя дальше. При этом остаток становится = 2.
> Cуффикс **a** из предыдущего шага никогда не был вставлен должным образом.  
Он остался, и поскольку мы продвинулись на один шаг, он вырос с а до ab.
> и необходимо вставить новое финальное ребро b.

![Дерево для строки "abcab"](/images/img4_1.jpg)  
_Рис.8 Дерево для строки "abcab"_


Добавляем следующий символ **x**. Переменная # = 6.  
На рисунке выше видно, что мы не можем спуститься дальше по ребру, так как символа **х** нет.
Поэтому мы делим ребро и подвешиваем новую вершину. Теперь наше дерево имеет вид:

![Дерево для строки "abcabx"](/images/img4_2.jpg)    
_Рис.9 Построение дерева для строки "abcabx"_


Теперь нужно вставить следующий оставшиеся суффиксы. Но прежде чем сделать это, необходимо обновить нашу позицию.
После каждого разделения, в случае если активной вершиной является корень, наши переменные изменятся:
> - активная вершина остается корнем  
> - активное ребро увеличивается на один (мы начинаем искать ребро со след. символом, в данном случае b)  
> - активная длина уменьшается на один (т.к один суффикс мы уже добавили)

Итак, мы снова находимся внутри ребра, осталось добавить 2 суффикса, спуститься дальше мы не можем, поэтому снова делим ребро:

![Дерево для строки "abcabx"](/images/img4_3.jpg)  
_Рис.10 Построение дерева для строки "abcabx"_


> Если ребро разделяется и вставляется новая вершина, и если это не первая вершина, созданная на текущем шаге, ранее вставленная вершина и новая вершина соединяются через специальный указатель, **суффиксную ссылку**

Мы добавили второй суффикс, теперь остаток = 1. Так как мы находимся в корне, то мы просто добавляем новое ребро **х**. Остаток = 0.  

![Дерево для строки "abcabx"](/images/img4_4.jpg)    
_Рис.11 Дерево для строки "abcabx"_


На данный момент мы имеем дерево для строки **abcabx**.  
Пропустим следующие два шага с добавлением символом a и b, так как на них мы просто спускаемся по ребру и приходим к его концу.
Переменная # равна 7, а остаток = 2: 

![Дерево для строки "abcabxab"](/images/img4_5.jpg)  
_Рис.12 Дерево для строки "abcabx", активная вершина 4_

На следующем шаге, переменная # = 8, добавляем символ **z**, так как ребра начинающегося на данный символ нет - создадим новое ребро и перескочим по суффиксной ссылке.
> После разделения или добавления ребра из активной вершины, которая не является корнем, переходим по суффиксной ссылке, выходящей из этой вершины, если таковая имеется. Если суффиксная ссылка отсутствует, активная вершина устанавливается корнем. активное ребро и активная длина остаются без изменений.  

![Дерево для строки "abcabxab"](/images/img4_6.jpg)  
_Рис.13 Построение дерева для строки "abcabxabz"_

Так как остаток = 1, добавим в вершину в которую пришли новое ребро с соответствующим символом:

![Дерево для строки "abcabxab"](/images/img4_7.jpg)  
_Рис.13 Построение дерева для строки "abcabxabz"_  

Теперь мы находимся в корне, следующим шагом будет добавление нового ребра **z** и **$**, переменная # = 9:

![Дерево для строки "abcabxabz$"](/images/img4_8.jpg)  
_Рис.13 Дерево для строки "abcabxabz$"_  

> Так как дерево должно содержать все суффиксы строки, причем каждый суффикс заканчивается точно в листе и нигде кроме него, используется специальный символ $.
> Любой суффикс строки с защитным символом действительно заканчивается в листе и только в листе, т. к. в такой строке не существует двух различных подстрок одинаковой длины, заканчивающихся на $.

На этом построение дерево для нашей строки закончено.

## Теория
### Правила продления суффиксов
Пусть _S[j..i]_ = β — суффикс _S[1..i]_. В продолжении j, когда алгоритм находит конец β в текущем дереве, он продолжает β, чтобы обеспечить присутствие суффикса _βS(i + 1)_ в дереве. Алгоритм действует по одному из следующих трех правил.

__Правило 1.__ В текущем дереве путь β кончается в листе. Это значит, что путь от корня с меткой β доходит до конца некоторой «листовой» дуги (дуги, входящей в лист). При изменении дерева нужно добавить к концу метки этой листовой дуги символ _S(i + 1)_.  

__Правило 2.__ Ни один путь из конца строки β не начинается символом _S(i + 1)_, но по крайней мере один начинающийся оттуда путь имеется. В этом случае должна быть создана новая листовая дуга, начинающаяся в конце β, помеченная символом _S(i + 1)_. При этом, если β кончается внутри дуги, должна быть создана новая вершина. Листу в конце новой листовой дуги сопоставляется номер j. Таким образом, в правиле 2 возможно два случая.  

__Правило 3.__ Некоторый путь из конца строки β начинается символом _S(i + 1)_. В этом случае строка _βS(i + 1)_ уже имеется в текущем дереве, так что ничего не надо делать (в неявном суффиксном дереве конец суффикса не нужно помечать явно).
### Наивный метод O(n³)
Алгоритм последовательно строит неявные суффиксные деревья_ для всех префиксов исходного текста _S = s₁s₂…sₙ_. 
На i-ой фазе неявное суффиксное дерево tᵢ-₁ для префикса _s[1…i − 1]_ достраивается до tᵢ для префикса _s[1…i]_. 
Достраивание происходит следующим образом: для каждого суффикса подстроки _s[1…i − 1]_ необходимо спуститься от корня дерева до конца этого суффикса и дописать символ sᵢ.  

Алгоритм состоит из n фаз. На каждой фазе происходит продление всех суффиксов текущего префикса строки, что требует O(n²) времени. Следовательно, общая асимптотика алгоритма составляет O(n³).

>__Неявное суффиксное дерево__ (англ. implicit suffix tree, IST) — это суффиксное дерево, построенное для строки S без добавления $.
### Суффиксные ссылки
> Пусть xA обозначает произвольную строку, где x — её первый символ, а A — оставшаяся подстрока (возможно пустая). Если для внутренней вершины _v_ с ребром xА существует другая вершина _s(v)_ с ребром α, то ссылка из _v_ в _s(v)_ называется __суффиксной ссылкой__ (англ. suffix link).
#### Построение суффиксных ссылок
Рассмотрим новую внутреннюю вершину _v_, которая была создана в результате продления суффикса _s[j…i − 1]_. 
Вместо того, чтобы искать, куда должна указывать суффиксная ссылка вершины _v_, поднимаясь от корня дерева для этого, перейдем к продлению следующего суффикса _s[j+1…i−1]_. И в этот момент можно проставить суффиксную ссылку для вершины _v_. 
Она будет указывать либо на существующую вершину, если следующий суффикс закончился в ней, либо на новую созданную. То есть суффиксные ссылки будут обновляться с запаздыванием.
#### Использование суффиксных ссылок
Пусть только что был продлён суффикс _[j…i − 1]_ до суффикса _s[j…i]_.  
Теперь с помощью построенных ссылок можно найти конец суффикса _s[j + 1…i − 1]_ в суффиксном дереве, чтобы продлить его до суффикса _s[j + 1…i]_. Для этого надо пройти вверх по дереву до ближайшей внутренней вершины _v_, в которую ведёт путь, помеченный _s[j…r]_. У вершины _v_ точно есть суффиксная ссылка. Эта суффиксная ссылка ведёт в вершину _u_, которой соответствует путь, помеченный подстрокой _s[j + 1…r]_. Теперь от вершины u следует пройти вниз по дереву к концу суффикса _s[j + 1…i − 1]_ и продлить его до суффикса _s[j + 1…i]_.

Подстрока _s[j + 1…i − 1]_ является суффиксом подстроки _s[j…i − 1]_, следовательно после перехода по суффиксной ссылке в вершину, помеченную путевой меткой _s[j + 1…r]_, можно дойти до места, которому соответствует метка _s[r + 1…i − 1]_, сравнивая не символы на рёбрах, а лишь длину ребра по первому символу рассматриваемой части подстроки и длину самой этой подстроки. Таким образом можно спускаться вниз сразу на целое ребро.
#### Первая лемма
При переходе по суффиксной ссылке глубина уменьшается не более чем на 1.
>_Глубиной вершины назовем число рёбер на пути от корня до вершины _v__.

__Доказательство__:
Заметим, что на пути A в дереве по суффиксу _s[j + 1…i]_ не более чем на одну вершину меньше, чем на пути B по суффиксу _s[j…i]_. Каждой вершине _v_ на пути B соответствует вершина _u_ на пути A, в которую ведёт суффиксная ссылка. Разница в одну вершину возникает, если первому ребру в пути B соответсвует метка из одного символа _sⱼ_, тогда суффиксная ссылка из вершины, в которую ведёт это ребро, будет вести в корень.
#### Вторая лемма
Число переходов по рёбрам внутри фазы номер i равно O(i).  

__Доказательство__:
Оценим количество переходов по рёбрам при поиске конца суффикса. Переход до ближайшей внутренней вершины уменьшает высоту на 1. Переход по суффиксной ссылке уменьшает высоту не более чем на 1 (по лемме, доказанной выше). А потом высота увеличивается, пока мы переходим по рёбрам вниз. Так как высота не может увеличиваться больше глубины дерева, а на каждой j-ой итерации мы уменьшаем высоту не более, чем на 2, то суммарно высота не может увеличиться больше чем на 2i. Итого, число переходов по рёбрам за одну фазу в сумме составляет O(i).

#### Асимптотика алгоритма с использованием суффиксных ссылок
Теперь в начале каждой фазы мы только один раз спускаемся от корня, а дальше используем переходы по суффиксным ссылкам.   
По доказанной лемме переходов внутри фазы будет O(i). А так как фаза состоит из i итераций, то амортизационно получаем, что на одной итерации будет выполнено O(1) действий.  
Следовательно, асимптотика алгоритма улучшилась до O(n²).

### Алгоритм O(n)
Чтобы улучшить время работы данного алгоритма до O(n), нужно использовать линейное количество памяти, поэтому метка каждого ребра будет храниться как два числа — позиции её самого левого и самого правого символов в исходном тексте.
#### Итоговая оценка времени работы
В течение работы алгоритма создается не более O(n) вершин по лемме о размере суффиксного дерева для строки. Все суффиксы, которые заканчиваются в листах, благодаря первой лемме на каждой итерации мы увеличиваем на текущий символ по умолчанию за O(1). Текущая фаза алгоритма будет продолжаться, пока не будет использовано правило продления 3.  
Сначала неявно продлятся все листовые суффиксы, а потом по правилу 2 будет создано несколько новых внутренних вершин. Так как вершин не может быть создано больше, чем их есть, то амортизационно на каждой фазе будет создано O(1) вершин. Так как мы на каждой фазе начинаем добавление суффикса не с корня, а с индекса j∗, на котором в прошлой фазе было применено правило 3, то используя немного модифицированный вариант леммы о числе переходов внутри фазы нетрудно показать, что суммарное число переходов по рёбрам за все n фаз равно O(n).

Таким образом, при использовании всех приведённых эвристик алгоритм Укконена работает за O(n).
## Реализация
### Cтруктура дерева
> #### Вершина (node)
> - `int left, *right` - индекс первого / последнего символа суффикса
> - `node *suff_link` - суффиксная ссылка
> - `map<char, *node> childs` - массив детей
> - `конструктор node`

> `string str` - строка, по которой строится дерево  
> `node *active_node` - вершина с которой начнется расширение  
> `int active_edge`  - активное ребро, иначе говоря индекс символа ребра по которому будем спускаться  
> `int active_length`  - длина которую прошли по ребру  
> `int remainder`  - остаток суффиксов  
> `int suff_end` - хранит последний индекс для листьев  
> `node *root` - корень дерева  
> `node *last_created` - последняя созданная вершина 

### Конструктор Node
```c++
node(int left, int *right, node *suffix_link, int suff_index) {
this->left = left;
this->right = right;
this->suff_link = suffix_link;
this->suff_index = suff_index;
}
```
### Функция подсчета длины ребра
```c++
int suffix_length(node *node) {
    return *node->right - node->left + 1;
}
```
### Функция построения дерева
```c++
void build(string data) {
    str = data + "$";
    active_node = root;

    for(int i = 0; i < str.length(); i++){
        update_tree(i);
    }
}
```
### Функция расширения дерева
```c++
void update_tree(int index){
    last_created = nullptr;
    remainder++;
    suff_end++;
    
    while (remainder != 0){
        // задаем активное ребро
        if (active_length == 0) {
            active_edge = index;
        }
        // ищем ребенка(суффикс) который начинается на заданный символ
        auto finded_child = active_node->childs.find(str[active_edge]);
        node *finded_node = finded_child->second;
        
        // если нет такого суффикса который начинается на данный символ
        if (finded_child == active_node->childs.end()){
            node *added_letter = new node(index, &suff_end, root, index - remainder + 1);
            active_node->childs.insert(make_pair(str[index], added_letter));
            if (last_created != nullptr) {
                last_created->suff_link = active_node;
                last_created = nullptr;
            }
        }
        else {
            // если можем спуститься к ноде - спускаемся
            if (active_length == suffix_length(finded_node)){
                   active_node = finded_node;
                   active_length = 0;
                   active_edge = -1;
                   continue;
            }
            //если можем спуститься по ребру - спускаемся
            if (str[index] == str[finded_child->second->left + active_length]){
                if (last_created != nullptr && active_node != root) last_created->suff_link = active_node;
                active_length++;
                break;
            }
            // деление ребра
            node *new_node = new node(finded_node->left, new int(finded_node->left + active_length - 1), root, -1);
            // создаем суффиксную ссылку
            if (last_created != nullptr) last_created->suff_link = new_node;
            active_node->childs[str[active_edge]] = new_node;
            finded_node->left += active_length;
            new_node->childs.insert(make_pair(str[index], new node(index, &suff_end, root, index - remainder + 1)));
            new_node->childs.insert(make_pair(str[finded_node->left], finded_node));
            last_created = new_node;
        }
        remainder--;
        
        if (active_length > 0 && active_node == root){
            active_length--;
            active_edge++;
        }
        else if (active_node != root){
            active_node = active_node->suff_link;
        }
    }
}
```
### Вывод дерева
```c++
void print(node *start, int lvl) {
    // перебор нод
    for(auto i : start->childs){
        for(int k = 0; k < lvl; k++){
            cout << "-----";
        }
        // вывод суффикса
        for(int j = i.second->left; j <= *(i.second->right); j++){
            cout << str[j];
        }
        cout << endl;
        // спуск по детям
        if(!(start->childs.empty())){
            print(i.second, lvl+1);
        }
    }
}
```
## Источники  
- [Простое суффиксное дерево / Хабр](https://habr.com/ru/post/258121/)
- [Алгоритм Укконена — Викиконспекты](https://vk.cc/cj1OgK)
- [АиСД S03E12. Суффиксное дерево. Алгоритм Укконена](https://www.youtube.com/watch?v=WjzR1eFbAeo&t=1328s&ab_channel=PavelMavrin)
- [Visualization of Ukkonen's Algorithm](http://brenden.github.io/ukkonen-animation/)
- [Ukkonen's suffix tree algorithm in plain English / stackoverflow](https://stackoverflow.com/questions/9452701/ukkonens-suffix-tree-algorithm-in-plain-english/9513423#9513423)
- [Suffix tree. Ukkonen's algorithm - Codeforces](https://codeforces.com/blog/entry/16780?f0a28=1)

